# 背景

最近发现了一门网课，作者是Oracle的一位大牛，他列出了一个课程的大纲，大纲包含了从java基础到到进阶的36个题目。为了巩固自己java的基础知识，或者补充自己某一方面的盲区，我尝试在这篇博客里写一下我对这36个题目的理解。

# 题目

## 1. 谈谈你对Java体系的理解？"Java是解释执行", 这句话是正确的吗？

java相对于传统的编译型语言比如C++，有着一些显而易见的优势。
1) 编译一次，到处运行，当然这得益于java强大的字节码体系以及字节码解释器。java代码编写好后会被编译成jvm标准规范的字节码，这些字节码理论上可以运行在不同的jvm上。虽然不同的jvm内部实现不尽相同，但是对于字节码的解释执行却应该是相同的。
2) gc。在使用C++的是时候，你再申请新的内存的时候需要时刻记着释放这些内存，否则就会出现内存泄漏的问题。java则不需要担心这些问题，对象的回收由jvm自动完成，大大的提升了生产效率。当然，你需要针对不同的场景优化gc的配置，以达到不同的目的。
3) 完善的库结构，jdk里面包含了各种各样常用的库，包含不同的数据结构、常用的并发策略、强大的io库、math库、日期库等等。。这些库久经考验，并且性能卓越，在避免造轮子引入各种奇怪问题的同时，大大的提高了生产效率
4) j2me，j2se，j2ee三大标准，满足了从移动设备，到pc桌面，再到服务器各种应用场景，可以说是覆盖了人们生活的方方面面。

java是解释执行这句话对也不对，在多数情况下java是解释执行的，由jvm读入字节码，然后解释执行。但是在某些场景下，jvm会把一些代码编译成本地码，这样做的好处是为了高效的运行。jvm编译的信息可以通过-XX:+PrintCompilation看到，以下面的代码为例，
```
public class Compiled {
    public static int increment(int i) {
        return i + 1;
    }
    public static void main(String[] args) {
        int j = 0;
        for (int i = 0; i < 50000; i++) {
            j = increment(j);
            if (j % 500000 == 0) {
            }
        }
    }
}
```
通过下面的配置运行程序后，
```
-XX:+PrintCompilation
-XX:CompileThreshold=10000
```
可以看到如下的输出
```
    182   32       3       java.util.HashMap::getNode (148 bytes)
    182   34       3       java.util.HashMap::putVal (300 bytes)
    183   35       2       Compiled::increment (4 bytes)
    183   33       3       java.util.HashMap::hash (20 bytes)
    184   36       1       Compiled::increment (4 bytes)
    184   35       2       Compiled::increment (4 bytes)   made not entrant
    185   30       4       java.io.WinNTFileSystem::isSlash (18 bytes)
```
184对应的是编译信息。

## 2. 请对比Exception和Error，运行时异常与一般异常有什么区别？

虽然Error和Exception都继承自Throwable，但是Error不应该被捕获以及处理，Error往往是致命的，比如VirtualMachineError。

运行时异常是unchecked的，不需要明确的声明会抛出这种异常，运行时异常也是可以不去捕获处理的，比如NullPointerException。一般异常是checked，必须明确的声明会抛出这种异常，这种异常也是需要去捕获处理的，比如FileNotFoundException。

https://stackoverflow.com/questions/912334/differences-between-exception-and-error

## 3. final、finally、finalize有什么不同？

这三个关键字的用途完全不一样。

final用在修饰变量的时候表示该变量不可修改，用于修饰方法的时候表明该方法不能被overrider，用于修饰类的时候表明该类不能被继承。

finally用于封装一定要运行的某些代码，比如资源的释放等。

finalize是一对象的一个方法，该方法在对象释放的时候调用。

## 强引用、软引用、弱引用、幻想引用有什么区别？具体使用场景是什么？

## 理解java的字符串，String、StringBuffer、StringBuilder有什么区别？

String对应的字符串是没有办法修改的，如果需要修改则需要指向新的字符串。StringBuffer和StringBuilder可以修改的，StringBuffer是线程安全的，StringBuilder是线程不安全的，不逃逸的局部变量应该尽量使用StringBuilder，如果多线程修改则尽量使用StringBuffer。

StringBuffer的方法是这样的，
```
public synchronized StringBuffer append(Object obj)
```
而StringBuilder是这样的，
```
public StringBuilder append(Object obj)
```

## 谈谈Java反射机制，动态代理是基于什么原理？

java的反射机制：
在运行时，获取某个类的属性、方法，并且能够修改属性或者方法的作用域，比如将private改为public。通过反射我们还能动态的创建某些类的实例，这方便我们通过配置来扩展程序，比如Spring通过xml来定义bean，这些bean的初始化就是通过反射来进行的。

动态代理的代理类需要实现java.lang.reflect.InvocationHandler接口，其中的invoke方法来完成实际的代理工作。然后通过调用Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)来完成最终代理对象的生成。

newProxyInstance根据interfaces实现实现新的类，这个类有一个参数为InvocationHandler的构造函数，同时有一个属性h，其类型也是InvocationHandler，该类实现的接口对应的方法内部调用代理类的invoke方法。可以用下面的代码来描述下，
```
public interface A {
    public void t(int i);
}

public ProxyA implments A {
    private InvocationHandler h;
    public void t(int i) {
        Method method = A.class.getMethod("t", Integer.class);
        return h.invoke(this, method, i);
    }
}

```

新的类生成完成后，newProxyInstance通过反射调用新生成类的构造方法类生成新的实例。


## int和Integer有什么区别，Integer值的缓存范围是什么？
int是原始类型，而Integer是普通的类。
```
Integer i1 = new Integer(1);
Integer i2 = new Integer(1);
boolean e = i1 == i2;
```
e是false，这是因为Integer的比较还需要比较内存地址。


Integer的缓存范围是[-128,127]