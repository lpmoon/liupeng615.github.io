# 背景

最近发现了一门网课，作者是Oracle的一位大牛，他列出了一个课程的大纲，大纲包含了从java基础到到进阶的36个题目。为了巩固自己java的基础知识，或者补充自己某一方面的盲区，我尝试在这篇博客里写一下我对这36个题目的理解。

# 题目

## 1. 谈谈你对Java体系的理解？"Java是解释执行", 这句话是正确的吗？

java相对于传统的编译型语言比如C++，有着一些显而易见的优势。
1) 编译一次，到处运行，当然这得益于java强大的字节码体系以及字节码解释器。java代码编写好后会被编译成jvm标准规范的字节码，这些字节码理论上可以运行在不同的jvm上。虽然不同的jvm内部实现不尽相同，但是对于字节码的解释执行却应该是相同的。
2) gc。在使用C++的是时候，你再申请新的内存的时候需要时刻记着释放这些内存，否则就会出现内存泄漏的问题。java则不需要担心这些问题，对象的回收由jvm自动完成，大大的提升了生产效率。当然，你需要针对不同的场景优化gc的配置，以达到不同的目的。
3) 完善的库结构，jdk里面包含了各种各样常用的库，包含不同的数据结构、常用的并发策略、强大的io库、math库、日期库等等。。这些库久经考验，并且性能卓越，在避免造轮子引入各种奇怪问题的同时，大大的提高了生产效率
4) j2me，j2se，j2ee三大标准，满足了从移动设备，到pc桌面，再到服务器各种应用场景，可以说是覆盖了人们生活的方方面面。

java是解释执行这句话对也不对，在多数情况下java是解释执行的，由jvm读入字节码，然后解释执行。但是在某些场景下，jvm会把一些代码编译成本地码，这样做的好处是为了高效的运行。jvm编译的信息可以通过-XX:+PrintCompilation看到，以下面的代码为例，
```
public class Compiled {
    public static int increment(int i) {
        return i + 1;
    }
    public static void main(String[] args) {
        int j = 0;
        for (int i = 0; i < 50000; i++) {
            j = increment(j);
            if (j % 500000 == 0) {
            }
        }
    }
}
```
通过下面的配置运行程序后，
```
-XX:+PrintCompilation
-XX:CompileThreshold=10000
```
可以看到如下的输出
```
    182   32       3       java.util.HashMap::getNode (148 bytes)
    182   34       3       java.util.HashMap::putVal (300 bytes)
    183   35       2       Compiled::increment (4 bytes)
    183   33       3       java.util.HashMap::hash (20 bytes)
    184   36       1       Compiled::increment (4 bytes)
    184   35       2       Compiled::increment (4 bytes)   made not entrant
    185   30       4       java.io.WinNTFileSystem::isSlash (18 bytes)
```
184对应的是编译信息。

## 2. 请对比Exception和Error，运行时异常与一般异常有什么区别？

虽然Error和Exception都继承自Throwable，但是Error不应该被捕获以及处理，Error往往是致命的，比如VirtualMachineError。

运行时异常是unchecked的，不需要明确的声明会抛出这种异常，运行时异常也是可以不去捕获处理的，比如NullPointerException。一般异常是checked，必须明确的声明会抛出这种异常，这种异常也是需要去捕获处理的，比如FileNotFoundException。

https://stackoverflow.com/questions/912334/differences-between-exception-and-error

## 3. final、finally、finalize有什么不同？

这三个关键字的用途完全不一样。

final用在修饰变量的时候表示该变量不可修改，用于修饰方法的时候表明该方法不能被overrider，用于修饰类的时候表明该类不能被继承。

finally用于封装一定要运行的某些代码，比如资源的释放等。

finalize是一对象的一个方法，该方法在对象释放的时候调用。

## 4. 强引用、软引用、弱引用、幻想引用有什么区别？具体使用场景是什么？

## 5. 理解java的字符串，String、StringBuffer、StringBuilder有什么区别？

String对应的字符串是没有办法修改的，如果需要修改则需要指向新的字符串。StringBuffer和StringBuilder可以修改的，StringBuffer是线程安全的，StringBuilder是线程不安全的，不逃逸的局部变量应该尽量使用StringBuilder，如果多线程修改则尽量使用StringBuffer。

StringBuffer的方法是这样的，
```
public synchronized StringBuffer append(Object obj)
```
而StringBuilder是这样的，
```
public StringBuilder append(Object obj)
```

## 6. 谈谈Java反射机制，动态代理是基于什么原理？

java的反射机制：
在运行时，获取某个类的属性、方法，并且能够修改属性或者方法的作用域，比如将private改为public。通过反射我们还能动态的创建某些类的实例，这方便我们通过配置来扩展程序，比如Spring通过xml来定义bean，这些bean的初始化就是通过反射来进行的。

动态代理的代理类需要实现java.lang.reflect.InvocationHandler接口，其中的invoke方法来完成实际的代理工作。然后通过调用Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)来完成最终代理对象的生成。

newProxyInstance根据interfaces实现实现新的类，这个类有一个参数为InvocationHandler的构造函数，同时有一个属性h，其类型也是InvocationHandler，该类实现的接口对应的方法内部调用代理类的invoke方法。可以用下面的代码来描述下，
```
public interface A {
    public void t(int i);
}

public ProxyA implments A {
    private InvocationHandler h;
    public void t(int i) {
        Method method = A.class.getMethod("t", Integer.class);
        return h.invoke(this, method, i);
    }
}

```

新的类生成完成后，newProxyInstance通过反射调用新生成类的构造方法类生成新的实例。


## 7. int和Integer有什么区别，Integer值的缓存范围是什么？
int是原始类型，而Integer是普通的类。
```
Integer i1 = new Integer(1);
Integer i2 = new Integer(1);
boolean e = i1 == i2;
```
e是false，这是因为Integer的比较还需要比较内存地址。


Integer的缓存范围是[-128,127]

## 8. 对比Vector、ArrayList、LinkedList有何区别？
1. 实现方式  
   Vector和ArrayList内部通过数组实现，LinkedList通过。前二者实现AbstractList，后一个实现AbstractSequentialList。
2. 查找方式  
   前两个通过index查找复杂度是O(1)，LinkedList的复杂度是O(n)
3. 数据插入  
   前两者需要考虑数组容量，容量不够的时候需要扩容，然后定位到对应位置。LinkedList需要遍历链表到对应的数据（根据index决定是前向遍历，还是后向遍历）。
4. 数据删除  
   前两者删除涉及到内存的拷贝，LinkedList的删除则不涉及内存拷贝
5. 并发性  
   vector是并发的，而后两者是非线程安全的

## 9. 对比Hashtable、HashMap、TreeMap，谈谈你对HashMap的掌握
1. Hashtable是线程安全的，实现了Dictionary、Map接口。放入的元素的key可以是null。内部实现是数组。
2. HashMap不是线程安全的，实现了Map接口。放入的元素的key不可以是null。内部实现是数组。
3. TreeMap不是线程安全的，实现了Map接口。放入的元素的key不可以是null。内部实现是红黑树。所有的key是有序的，在toStiring输出的时候也是有序的。实现了NavigableMap接口，可以获取有序的字序列。

在jdk1.8中，HashMap由数组实现。数组的每一个元素都是Node的实例，每一个Node对应一个链表，链表中的每一个元素hash值相同。当插入数据的时候首先计算key对应的hash值，然后用hash & (n - 1)来计算新数据的slot index，然后进行插入，这里分为以下几种情况:  
a. slot index中没有数据，直接插入  
b. slot index中有数据，如果类型是TreeNode，则将当前数据插入到二叉树中  
c. slot index中有数据，并且不是TreeNode，则遍历链表，将对应的数据插入链表的尾部，或者替换已有的数据(key相同的)。如果是新插入的话，则需要判断当前的slot index对应的链表的长度是否大于等于TREEIFY_THRESHOLD，如果满足条件则将当前的链表调整为一个二叉树。  
d. 当map中的元素数大于阈值的时候，需要对map扩容，table size * 2  

## 10. 如何保证集合是线程安全的？ConcurrentHashMap做了什么？
1）使用集合的同步版本，比如使用Vector替换ArrayList，ConcurrentHashMap替换HashMap等
2）使用synchronized，或者jdk提供的其他同步策略，对并发的场景进行加锁操作，保证同步
3) 使用Collections.SynchronizedXXX对集合做同步封装，封装后得到的集合为同步的。

ConcurrentHashMap将Map的table分为多个segment，ConcurrentHashMap的锁或者同步机制加在segment上，保证了锁粒度的最小化，大大的提高了并发性。